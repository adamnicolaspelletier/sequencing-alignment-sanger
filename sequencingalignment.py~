
###                                            -*- Mode: Python -*-
###                                            -*- coding UTF-8 -*-
### scriptname.py
### Copyright 2016 Institut de Recherche en Immunologie et Cancerologie (IRIC)
### Author :  Adam-Nicolas Pelletier
### Last modified On: 29-03-16


from Bio.Align.Applications import MuscleCommandline
from Bio.Emboss.Applications import WaterCommandline
from StringIO import StringIO
from Bio import AlignIO
from Bio.Alphabet.IUPAC import IUPACAmbiguousDNA
from Bio import SeqIO
import glob  #module for file wildcards. can use genename as reference to look for several transcript fasta sequences at once. CHANGE PATH.
import os
import pandas as pd
import numpy as np
import fileinput

########################################################################################################################################################
########################################################## USER INPUT  AND OUTPUT ######################################################################
filenames = "filenames.txt"

fastqfile = "ABI_files/fastaSeq5868.txt"
ccdsfile = "ccds_seq.fasta"
outputfile2 = "internal_files/muscle2.txt"
outputfile3 = "internal_files/muscle3.txt"
outputfile4 = "internal_files/muscle4.txt"
#finaloutput = "output_clustal/%s.txt"

isoformfile = "isoform_list.txt"

letters = {0:"A",1:"C",2:"G",3:"T", 4:"N"}  # dictionary of indexes of each nucleotide for matrices
lettersinv = {"A":0,"C":1,"G":2,"T":3, "N":4}
########################################################################################################################################################
########################################################################################################################################################

def reversecomp(rprimsequence): ## make a complement version of the sequence, and reverse it so it has the proper orientation
	a = ""
	tempzrev = rprimsequence
	tempzrev = tempzrev.replace("T","X")
	tempzrev = tempzrev.replace("A","T")
	tempzrev = tempzrev.replace("X","A")
	tempzrev = tempzrev.replace("C","Y")
	tempzrev = tempzrev.replace("G","C")
	tempzrev = tempzrev.replace("Y","G")
	templist = list(tempzrev)
	templist.reverse()
	for i in templist:
		a += i
	return a


# fasta_sequences = SeqIO.parse(open(input_file),'fasta')
# with open(output_file) as out_file:
#     for fasta in fasta_sequences:
#         name, sequence = fasta.id, fasta.seq.tostring()
#         new_sequence = some_function(sequence)
#         write_fasta(out_file)

# Generate the list of PWMs to use
# filelist = []
# for i in os.listdir("Homosapiens_CISBP/pwmsUnif"):
#   if i.endswith(".txt"):
#       filelist.append("Homosapiens_CISBP/pwmsUnif"+"/")



# promoterlist = []
# for i in os.listdir("promoter_files/seeded/"+str(n)+"bp/"):
#     if i.endswith(".txt"):
#         promoterlist.append("promoter_files/seeded/"+str(n)+"bp/"+i)

isoforms = open(isoformfile).read().splitlines()
outputfile = "ABI_files/fasta/tempoutput.txt"

phred_dict = {}

handle = open("ABI_files/fastaSeq5868.txt", "rU")

for record in SeqIO.parse(handle, "fastq"):
	phred_dict[record.id] = record.letter_annotations['phred_quality']

def consensus():
	pass

def fastaconvert(fastalist):  #convert a conventional fasta file into a list of IDs and whole sequences (merges the 50 characters per line)
	a = ""
	x = ""
	z = []
	for i in fastalist:
		if ">" in i:
			a = a.replace("\n","")
			z.append(a)
			x += i
			x = x.replace("\n","")
			z.append(x)
			a = ""
			x = ""
		else:
			a += i
	del z[0]
	return z

def idsplitter(ID):
	ID.pop()
	realID = []
	for i in ID:
		name = str(i)
		idsplit = name.split("|")
		realID.append(idsplit[2])
	return realID

def matrixconverter(seqmatrix, letters): 
    """generates a DNA sequence string based on a NumPy matrix"""
    a = np.transpose(np.nonzero(np.transpose(seqmatrix))).tolist()
    seqstring = ""
    for i in a:
        seqstring += letters[i[1]]
    return seqstring

def matrixmaker(dnastring):   
    """ Generates a numpy array from a DNA sequence string, made from ones and zeros. 2D representation of a DNA sequence. Complements the matrixconverter function""" 
    matrix = np.zeros( (5, len(dnastring)) )
    index = []
    for i in range(len(dnastring)):
        index.append([lettersinv[list(dnastring)[i]], i]) 
    a = np.array(index)  
    matrix[a[:,0], a[:,1]] = 1
    return matrix

def pwmwalk(pwm, sequence, pos): 
    """ Tests each position of a SHORT DNA sequence as a numpy array against a pwm array. Returns the best alignment score. 
    The Pos argument lets you define over which portion of the pwm you want to align. Add 0 for the whole thing. 
    Useful when you add buffer random sequences on the site to align earlier than the 0 position for both array and sequence, or further than the length of the array"""
    
    alphapos = 0
    alphascore = -1000              
    for i in xrange(pos,len(pwm.transpose())-pos):
    	
        try:
            betapos = i 
            betascore = np.sum(sequence * pwm[:,betapos:(betapos + len(sequence.transpose()))])
            #print betapos, betascore, alphapos, alphascore
            if betascore > alphascore:
                alphascore = betascore
                alphapos = betapos
        except ValueError:
            pass
    return [alphascore,alphapos]

def musclealigner(fwd_id, rev_id, fastqfile, ccdsfile, ccdslist, outputfile, outputfile2, outputfile3, outputfile4, finalf, fconstant, rconstant):
	""" Takes a supplied forward and reverse contig, with the corresponding theoritical isoform, to align all 3 together and generate a consensus sequence"""
	final = "internal_files/%s.txt" % (finalf)
	with open("internal_files/fastaoutput.txt", "w") as tempoutput:
		tempoutput.write("")
	with open("internal_files/outputfile2.txt", "w") as outputfile2:
		outputfile2.write("")
	with open("internal_files/outputfile3.txt", "w") as outputfile3:
		outputfile3.write("")
	with open(final, "w") as outputfile4:
		outputfile4.write("")
	with open("internal_files/fastaouttemp.txt", "w") as tempout:
		tempout.write("")	
	with open(final, "w") as foutpout:
		foutpout.write("")

###########3 Perhaps we need to replace nucleotides with N if they are below a score of 10 ish. jsut to reduce alignment in the extremities . 
###### First Alignment: F and reference ################################################################
# TRY TO IMPORT THE PRIMERS TO REMOVE THE CONSTANT PORTION OF THE SSEQUENCE FROM THE F AND R CONTIGS< TO REDUCE LIKELINESS OF ALIGNMENT ON THE TERMINAL PORTIONS. THEN, PROCEED WITH A MUSCLE ALIGNMENT FROM THE COMMAND LINE. 
# MUSCLE IN PYTOHN DOES NOT SEEM TO HAVE THE GAPOPEN PARAMETERS NECESSARY FOR PROPER ALIGNMENT OF CLOSELY RELATED SEQUENCES. 


# GAPOPEN = -200 IF EXPECTED INSERTIONS AND DELETIONS. IF MORE CLOSELY RELATED, -20 IS PROPBABLY FINE. set it up. 



	for record in SeqIO.parse(fastqfile, "fastq"):
		if record.id == fwd_id:
			# with open("internal_files/fastaouttemp.txt", "a") as tempout:
			# 	tempout.write('>' + "FWD" + "_" + record.id +'\n'+ seq.upper()+"\n")
			prout = record.seq.upper()[:100]	
			fpos = int(pwmwalk(matrixmaker(prout), matrixmaker(fconstant), 0)[1] + len(fconstant))

			seq = str(record.seq.upper())[fpos:]
			fphredint =  (record.letter_annotations['phred_quality'])[fpos:]
			with open("internal_files/fastaoutput.txt", "a") as tempoutput:
				tempoutput.write('>' + "FWD" + "_" + record.id +'\n'+ seq.upper()+"\n")		

		elif record.id == rev_id:
			prout = record.seq.upper()[:100]
			lenr = len(record.seq)	
			rpos = int(pwmwalk(matrixmaker(prout), matrixmaker(rconstant), 0)[1] + len(rconstant))
			
			print record.seq.upper()
			if rpos == 48:
				seq = str(record.seq.upper())[rpos-5:]
				print seq
				rphredint =  (record.letter_annotations['phred_quality'])[rpos-5:][::-1]
				#print rphredint
				#print len(seq)
				print len(rphredint)
			else:
				seq = str(record.seq.upper()[rpos-5:])
				rphredint =  (record.letter_annotations['phred_quality'])[rpos-5:][::-1]
				#print rphredint
				# print seq
				# print len(seq)
				# print len(rphredint)

			rcseq = str(seq).upper()
			
			with open("internal_files/fastaoutput.txt", "a") as tempoutput:
				tempoutput.write('>' + "REV" + "_" + record.id +'\n'+ reversecomp(rcseq)+"\n")	
	


	for recordc in SeqIO.parse(ccdsfile, "fasta"):
		if recordc.id == ccdslist:
			with open("internal_files/fastaoutput.txt", "a") as tempoutput:

				ccds_seq = recordc.seq		
				tempoutput.write('>' + recordc.id + '\n'+ str(ccds_seq.upper()))

		
	muscle_cline = MuscleCommandline(input="internal_files/fastaoutput.txt") 
	stdout, stderr = muscle_cline()
	muscle_cline.gapopen = -100.0
	align = AlignIO.read(StringIO(stdout), "fasta")
	AlignIO.write([align], "internal_files/muscleoutput.txt", "fasta")
	

	consensus = ""
	refseq = []
	fseq = []
	rseq = []
	refid = ""
	reffseq = ""
	fphred = []
	rphred = []

	for record in SeqIO.parse("internal_files/muscleoutput.txt", "fasta"):
	
		if fwd_id in str(record.id):
			fseq = list(str(record.seq))
	

		elif rev_id in str(record.id):
			rseq = list(str(record.seq))
			
		else:
			refseq = list(str(record.seq))
			refid = record.id
			reffseq = record.seq
			finalrefseq = record.seq
	 
	

	for i in xrange(len(fseq)):
		if fseq[i] == "-":
			fphred.append(0)
		else:
			fphred.append(fphredint.pop(0))

	for i in xrange(len(rseq)):
		if rseq[i] == "-":
			rphred.append(0)
		else:
			rphred.append(rphredint.pop(0))
	print len(rphred)
	print len(refseq)

	for i in xrange(len(refseq)):

		if refseq[i] == fseq[i] or refseq[i] == rseq[i] :
			consensus += refseq[i]
		elif fseq[i] == rseq[i]:
			consensus += fseq[i]
		elif fphred[i] > rphred[i]:
			consensus += fseq[i]
		elif fphred[i] < rphred[i]:
			consensus += rseq[i]
		else:
			consensus += "N"

	
	
	with open(final, "a") as foutput:	
		foutput.write('>' + str(finalf) + " Consensus" + '\n' + str(consensus) +'\n' + '>' + str(refid) +'\n' + str(reffseq) + '\n')



filenamedf = pd.read_csv(filenames, sep = "\t")
wells = filenamedf["Well"].tolist()


""" Get phred score from last value and use it on -. Otherwise, a badly read letter will always 
be prefered to a -, even if that - is in a region of the contig with a higher confidence score. """

for i in range(len(wells)):
	print filenamedf.iloc[i]["Genename"]
	fwd_id = filenamedf.iloc[i]["Fwd_file"]
	rev_id = filenamedf.iloc[i]["Rev_file"]
	ccdslist = []
	phred_fwd = phred_dict[fwd_id]
	phred_rev= phred_dict[rev_id][::-1]
	# print phred_fwd
	# print phred_rev
	for recordc in SeqIO.parse(ccdsfile, "fasta"):
		if recordc.id in isoforms:
			
			if filenamedf.iloc[i]["EnsID"] in recordc.id:
				ccdslist.append(recordc.id)
	

	musclealigner(fwd_id, rev_id, fastqfile, ccdsfile, ccdslist[0], outputfile, outputfile2, outputfile3, outputfile4, 
		filenamedf.iloc[i]["Genename"],filenamedf.iloc[i]["fconstant"],filenamedf.iloc[i]["rconstant"])	
	

	irrelevant = raw_input("Ready for next gene (y/n)?  ")			








# path = "/home/mydir/*.txt"
# for filename in glob.glob(path):
#     with open(filename, 'r') as f:
#         for line in f:
#             print line,


# forward_seq = "xxx.fasta"
# ccds_input_sequences = "%s.fasta" % well
# output_alignment = "output_alignment.fasta"

# def align_v1 (Fasta): 
#     muscle_cline = MuscleCommandline(muscle_exe, input=Fasta, out=output_alignment)
#     stdout, stderr = muscle_cline()
#     MultipleSeqAlignment = AlignIO.read(output_alignment, "fasta") 
#     print MultipleSeqAlignment


# input_sequences = "hiv_protease_sequences_w_wt.fasta"
# output_alignment = "output_alignment.fasta"

# def align_v1 (Fasta): 
#     muscle_cline = MuscleCommandline(muscle_exe, input=Fasta, out=output_alignment)
#     stdout, stderr = muscle_cline()
#     MultipleSeqAlignment = AlignIO.read(output_alignment, "fasta") 
#     print MultipleSeqAlig